### BTest baseline data generated by btest-diff. Do not edit. Use "btest -U/-u" to update. Requires BTest >= 0.63.
<!DOCTYPE html><html>  <head>    <style type="text/css">      table.GeneratedTable {   width: 100%;   background-color: #ffffff;   border-collapse: collapse;   border-width: 2px;   border-color: #ffcc00;   border-style: solid;   color: #000000;      }      table.GeneratedTable td, table.GeneratedTable th {   border-width: 2px;   border-color: #ffcc00;   border-style: solid;   padding: 3px;      }      table.GeneratedTable thead {   background-color: #ffcc00;      }      /* Style the button that is used to open and close the collapsible content */      .collapsible {   background-color: #eee;   color: #444;   cursor: pointer;   padding: 18px;   width: 100%;   border: none;   text-align: left;   outline: none;   font-size: 15px;      }      /* Add a background color to the button if it is clicked on (add the .active class with JS), and when you move the mouse over it (hover) */      .active, .collapsible:hover {   background-color: #ccc;      }      /* Style the collapsible content. Note: hidden by default */      .content {      padding: 0 18px;      display: none;      overflow: hidden;      background-color: #f1f1f1;      }                </style>    <script type="text/javascript">    </script>  <title>Log Definitions</title></head>  <body>    <h1>Logs!!!</h1>    <p>Here we intro the whole log guide.</p>    <button type="button" class="collapsible">conn</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>This is the time of the first packet.</td></tr>

<tr><td>uid</td><td>string</td><td>A unique identifier of the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>proto</td><td>string - enum</td><td>The transport layer protocol of the connection.</td></tr>

<tr><td>service</td><td>string</td><td>An identification of an application protocol being sent over the connection.</td></tr>

<tr><td>duration</td><td>number - interval</td><td>How long the connection lasted.  For 3-way or 4-way connection tear-downs, this will not include the final ACK.</td></tr>

<tr><td>orig_bytes</td><td>integer - count</td><td>The number of payload bytes the originator sent. For TCP this is taken from sequence numbers and might be inaccurate (e.g., due to large connections).</td></tr>

<tr><td>resp_bytes</td><td>integer - count</td><td>The number of payload bytes the responder sent. See <b>orig_bytes</b>.</td></tr>

<tr><td>conn_state</td><td>string</td><td>Possible <b>conn_state</b> values:      <br><b>S0</b>: Connection attempt seen, no reply.      <br><b>S1</b>: Connection established, not terminated.      <br><b>SF</b>: Normal establishment and termination.     Note that this is the same symbol as for state S1.     You can tell the two apart because for S1 there will not be any     byte counts in the summary, while for SF there will be.      <br><b>REJ</b>: Connection attempt rejected.      <br><b>S2</b>: Connection established and close attempt by originator seen     (but no reply from responder).      <br><b>S3</b>: Connection established and close attempt by responder seen     (but no reply from originator).      <br><b>RSTO</b>: Connection established, originator aborted (sent a RST).      <br><b>RSTR</b>: Responder sent a RST.      <br><b>RSTOS0</b>: Originator sent a SYN followed by a RST, we never saw a     SYN-ACK from the responder.      <br><b>RSTRH</b>: Responder sent a SYN ACK followed by a RST, we never saw a     SYN from the (purported) originator.      <br><b>SH</b>: Originator sent a SYN followed by a FIN, we never saw a     SYN ACK from the responder (hence the connection was "half" open).      <br><b>SHR</b>: Responder sent a SYN ACK followed by a FIN, we never saw a     SYN from the originator.      <br><b>OTH</b>: No SYN seen, just midstream traffic (one example of this     is a "partial connection" that was not later closed).</td></tr>

<tr><td>local_orig</td><td>boolean - bool</td><td>If the connection is originated locally, this value will be T. If it was originated remotely it will be F.  In the case that the <b>Site::local_nets</b> variable is undefined, this field will be left empty at all times.</td></tr>

<tr><td>local_resp</td><td>boolean - bool</td><td>If the connection is responded to locally, this value will be T. If it was responded to remotely it will be F.  In the case that the <b>Site::local_nets</b> variable is undefined, this field will be left empty at all times.</td></tr>

<tr><td>missed_bytes</td><td>integer - count</td><td>Indicates the number of bytes missed in content gaps, which is representative of packet loss.  A value other than zero will normally cause protocol analysis to fail but some analysis may have been completed prior to the packet loss.</td></tr>

<tr><td>history</td><td>string</td><td><table summary="deets"><tbody> <tr><td>s</td><td>a SYN w/o the ACK bit set</td></tr>  <tr><td>h</td><td>a SYN+ACK ("handshake")</td></tr>  <tr><td>a</td><td>a pure ACK</td></tr>  <tr><td>d</td><td>packet with payload ("data")</td></tr>  <tr><td>f</td><td>packet with FIN bit set</td></tr>  <tr><td>r</td><td>packet with RST bit set</td></tr>  <tr><td>c</td><td>packet with a bad checksum (applies to UDP too)</td></tr>  <tr><td>g</td><td>a content gap</td></tr>  <tr><td>t</td><td>packet with retransmitted payload</td></tr>  <tr><td>w</td><td>packet with a zero window advertisement</td></tr>  <tr><td>i</td><td>inconsistent packet (e.g. FIN+RST bits set)</td></tr>  <tr><td>q</td><td>multi-flag packet (SYN+FIN or SYN+RST bits set)</td></tr>  <tr><td>^</td><td>connection direction was flipped by Zeek's heuristic</td></tr>  </tbody></table>   If the event comes from the originator, the letter is in upper-case; if it comes from the responder, it's in lower-case.  The 'a', 'd', 'i' and 'q' flags are recorded a maximum of one time in either direction regardless of how many are actually seen.  'f', 'h', 'r' and 's' can be recorded multiple times for either direction if the associated sequence number differs from the last-seen packet of the same flag type. 'c', 'g', 't' and 'w' are recorded in a logarithmic fashion: the second instance represents that the event was seen (at least) 10 times; the third instance, 100 times; etc.</td></tr>

<tr><td>orig_pkts</td><td>integer - count</td><td>Number of packets that the originator sent. Only set if <b>use_conn_size_analyzer</b> = T.</td></tr>

<tr><td>orig_ip_bytes</td><td>integer - count</td><td>Number of IP level bytes that the originator sent (as seen on the wire, taken from the IP total_length header field). Only set if <b>use_conn_size_analyzer</b> = T.</td></tr>

<tr><td>resp_pkts</td><td>integer - count</td><td>Number of packets that the responder sent. Only set if <b>use_conn_size_analyzer</b> = T.</td></tr>

<tr><td>resp_ip_bytes</td><td>integer - count</td><td>Number of IP level bytes that the responder sent (as seen on the wire, taken from the IP total_length header field). Only set if <b>use_conn_size_analyzer</b> = T.</td></tr>

<tr><td>tunnel_parents</td><td>array[string] - set[string]</td><td>If this connection was over a tunnel, indicate the <b>uid</b> values for any encapsulating parent connections used over the lifetime of this inner connection.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">dce_rpc</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Timestamp for when the event happened.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique ID for the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>rtt</td><td>number - interval</td><td>Round trip time from the request to the response. If either the request or response wasn't seen, this will be null.</td></tr>

<tr><td>named_pipe</td><td>string</td><td>Remote pipe name.</td></tr>

<tr><td>endpoint</td><td>string</td><td>Endpoint name looked up from the uuid.</td></tr>

<tr><td>operation</td><td>string</td><td>Operation seen in the call.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">dhcp</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>The earliest time at which a DHCP message over the associated connection is observed.</td></tr>

<tr><td>uids</td><td>array[string] - set[string]</td><td>A series of unique identifiers of the connections over which DHCP is occurring.  This behavior with multiple connections is unique to DHCP because of the way it uses broadcast packets on local networks.</td></tr>

<tr><td>client_addr</td><td>string - addr</td><td>IP address of the client.  If a transaction is only a client sending INFORM messages then there is no lease information exchanged so this is helpful to know who sent the messages. Getting an address in this field does require that the client sources at least one DHCP message using a non-broadcast address.</td></tr>

<tr><td>server_addr</td><td>string - addr</td><td>IP address of the server involved in actually handing out the lease.  There could be other servers replying with OFFER messages which won't be represented here.  Getting an address in this field also requires that the server handing out the lease also sources packets from a non-broadcast IP address.</td></tr>

<tr><td>mac</td><td>string</td><td>Client's hardware address.</td></tr>

<tr><td>host_name</td><td>string</td><td>Name given by client in Hostname option 12.</td></tr>

<tr><td>client_fqdn</td><td>string</td><td>FQDN given by client in Client FQDN option 81.</td></tr>

<tr><td>domain</td><td>string</td><td>Domain given by the server in option 15.</td></tr>

<tr><td>requested_addr</td><td>string - addr</td><td>IP address requested by the client.</td></tr>

<tr><td>assigned_addr</td><td>string - addr</td><td>IP address assigned by the server.</td></tr>

<tr><td>lease_time</td><td>number - interval</td><td>IP address lease interval.</td></tr>

<tr><td>client_message</td><td>string</td><td>Message typically accompanied with a DHCP_DECLINE so the client can tell the server why it rejected an address.</td></tr>

<tr><td>server_message</td><td>string</td><td>Message typically accompanied with a DHCP_NAK to let the client know why it rejected the request.</td></tr>

<tr><td>msg_types</td><td>array[string] - vector of string</td><td>The DHCP message types seen by this DHCP transaction</td></tr>

<tr><td>duration</td><td>number - interval</td><td>Duration of the DHCP "session" representing the time from the first message to the last.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">dnp3</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Time of the request.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique identifier for the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>fc_request</td><td>string</td><td>The name of the function message in the request.</td></tr>

<tr><td>fc_reply</td><td>string</td><td>The name of the function message in the reply.</td></tr>

<tr><td>iin</td><td>integer - count</td><td>The response's "internal indication number".</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">dns</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>The earliest time at which a DNS protocol message over the associated connection is observed.</td></tr>

<tr><td>uid</td><td>string</td><td>A unique identifier of the connection over which DNS messages are being transferred.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>proto</td><td>string - enum</td><td>The transport layer protocol of the connection.</td></tr>

<tr><td>trans_id</td><td>integer - count</td><td>A 16-bit identifier assigned by the program that generated the DNS query.  Also used in responses to match up replies to outstanding queries.</td></tr>

<tr><td>rtt</td><td>number - interval</td><td>Round trip time for the query and response. This indicates the delay between when the request was seen until the answer started.</td></tr>

<tr><td>query</td><td>string</td><td>The domain name that is the subject of the DNS query.</td></tr>

<tr><td>qclass</td><td>integer - count</td><td>The QCLASS value specifying the class of the query.</td></tr>

<tr><td>qclass_name</td><td>string</td><td>A descriptive name for the class of the query.</td></tr>

<tr><td>qtype</td><td>integer - count</td><td>A QTYPE value specifying the type of the query.</td></tr>

<tr><td>qtype_name</td><td>string</td><td>A descriptive name for the type of the query.</td></tr>

<tr><td>rcode</td><td>integer - count</td><td>The response code value in DNS response messages.</td></tr>

<tr><td>rcode_name</td><td>string</td><td>A descriptive name for the response code value.</td></tr>

<tr><td>AA</td><td>boolean - bool</td><td>The Authoritative Answer bit for response messages specifies that the responding name server is an authority for the domain name in the question section.</td></tr>

<tr><td>TC</td><td>boolean - bool</td><td>The Truncation bit specifies that the message was truncated.</td></tr>

<tr><td>RD</td><td>boolean - bool</td><td>The Recursion Desired bit in a request message indicates that the client wants recursive service for this query.</td></tr>

<tr><td>RA</td><td>boolean - bool</td><td>The Recursion Available bit in a response message indicates that the name server supports recursive queries.</td></tr>

<tr><td>Z</td><td>integer - count</td><td>A reserved field that is usually zero in queries and responses.</td></tr>

<tr><td>answers</td><td>array[string] - vector of string</td><td>The set of resource descriptions in the query answer.</td></tr>

<tr><td>TTLs</td><td>array[number] - vector of interval</td><td>The caching intervals of the associated RRs described by the <b>answers</b> field.</td></tr>

<tr><td>rejected</td><td>boolean - bool</td><td>The DNS query was rejected by the server.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">dpd</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Timestamp for when protocol analysis failed.</td></tr>

<tr><td>uid</td><td>string</td><td>Connection unique ID.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>proto</td><td>string - enum</td><td>Transport protocol for the violation.</td></tr>

<tr><td>analyzer</td><td>string</td><td>The analyzer that generated the violation.</td></tr>

<tr><td>failure_reason</td><td>string</td><td>The textual reason for the analysis failure.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">files</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>The time when the file was first seen.</td></tr>

<tr><td>fuid</td><td>string</td><td>An identifier associated with a single file.</td></tr>

<tr><td>tx_hosts</td><td>array[string] - set[addr]</td><td>If this file was transferred over a network connection this should show the host or hosts that the data sourced from.</td></tr>

<tr><td>rx_hosts</td><td>array[string] - set[addr]</td><td>If this file was transferred over a network connection this should show the host or hosts that the data traveled to.</td></tr>

<tr><td>conn_uids</td><td>array[string] - set[string]</td><td>Connection UIDs over which the file was transferred.</td></tr>

<tr><td>source</td><td>string</td><td>An identification of the source of the file data.  E.g. it may be a network protocol over which it was transferred, or a local file path which was read, or some other input source.</td></tr>

<tr><td>depth</td><td>integer - count</td><td>A value to represent the depth of this file in relation to its source.  In SMTP, it is the depth of the MIME attachment on the message.  In HTTP, it is the depth of the request within the TCP connection.</td></tr>

<tr><td>analyzers</td><td>array[string] - set[string]</td><td>A set of analysis types done during the file analysis.</td></tr>

<tr><td>mime_type</td><td>string</td><td>A mime type provided by the strongest file magic signature match against the <b>bof_buffer</b> field of <b>fa_file</b>, or in the cases where no buffering of the beginning of file occurs, an initial guess of the mime type based on the first data seen.</td></tr>

<tr><td>filename</td><td>string</td><td>A filename for the file if one is available from the source for the file.  These will frequently come from "Content-Disposition" headers in network protocols.</td></tr>

<tr><td>duration</td><td>number - interval</td><td>The duration the file was analyzed for.</td></tr>

<tr><td>local_orig</td><td>boolean - bool</td><td>If the source of this file is a network connection, this field indicates if the data originated from the local network or not as determined by the configured <b>Site::local_nets</b>.</td></tr>

<tr><td>is_orig</td><td>boolean - bool</td><td>If the source of this file is a network connection, this field indicates if the file is being sent by the originator of the connection or the responder.</td></tr>

<tr><td>seen_bytes</td><td>integer - count</td><td>Number of bytes provided to the file analysis engine for the file.</td></tr>

<tr><td>total_bytes</td><td>integer - count</td><td>Total number of bytes that are supposed to comprise the full file.</td></tr>

<tr><td>missing_bytes</td><td>integer - count</td><td>The number of bytes in the file stream that were completely missed during the process of analysis e.g. due to dropped packets.</td></tr>

<tr><td>overflow_bytes</td><td>integer - count</td><td>The number of bytes in the file stream that were not delivered to stream file analyzers.  This could be overlapping bytes or bytes that couldn't be reassembled.</td></tr>

<tr><td>timedout</td><td>boolean - bool</td><td>Whether the file analysis timed out at least once for the file.</td></tr>

<tr><td>parent_fuid</td><td>string</td><td>Identifier associated with a container file from which this one was extracted as part of the file analysis.</td></tr>

<tr><td>md5</td><td>string</td><td>An MD5 digest of the file contents.</td></tr>

<tr><td>sha1</td><td>string</td><td>A SHA1 digest of the file contents.</td></tr>

<tr><td>sha256</td><td>string</td><td>A SHA256 digest of the file contents.</td></tr>

<tr><td>extracted</td><td>string</td><td>Local filename of extracted file.</td></tr>

<tr><td>extracted_cutoff</td><td>boolean - bool</td><td>Set to true if the file being extracted was cut off so the whole file was not logged.</td></tr>

<tr><td>extracted_size</td><td>integer - count</td><td>The number of bytes extracted to disk.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">ftp</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Time when the command was sent.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique ID for the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>user</td><td>string</td><td>User name for the current FTP session.</td></tr>

<tr><td>password</td><td>string</td><td>Password for the current FTP session if captured.</td></tr>

<tr><td>command</td><td>string</td><td>Command given by the client.</td></tr>

<tr><td>arg</td><td>string</td><td>Argument for the command if one is given.</td></tr>

<tr><td>mime_type</td><td>string</td><td>Sniffed mime type of file.</td></tr>

<tr><td>file_size</td><td>integer - count</td><td>Size of the file if the command indicates a file transfer.</td></tr>

<tr><td>reply_code</td><td>integer - count</td><td>Reply code from the server in response to the command.</td></tr>

<tr><td>reply_msg</td><td>string</td><td>Reply message from the server in response to the command.</td></tr>

<tr><td>data_channel.passive</td><td>boolean - bool</td><td>Whether PASV mode is toggled for control channel.</td></tr>

<tr><td>data_channel.orig_h</td><td>string - addr</td><td>The host that will be initiating the data connection.</td></tr>

<tr><td>data_channel.resp_h</td><td>string - addr</td><td>The host that will be accepting the data connection.</td></tr>

<tr><td>data_channel.resp_p</td><td>integer - port</td><td>The port at which the acceptor is listening for the data connection.</td></tr>

<tr><td>fuid</td><td>string</td><td>File unique ID.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">http</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Timestamp for when the request happened.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique ID for the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>trans_depth</td><td>integer - count</td><td>Represents the pipelined depth into the connection of this request/response transaction.</td></tr>

<tr><td>method</td><td>string</td><td>Verb used in the HTTP request (GET, POST, HEAD, etc.).</td></tr>

<tr><td>host</td><td>string</td><td>Value of the HOST header.</td></tr>

<tr><td>uri</td><td>string</td><td>URI used in the request.</td></tr>

<tr><td>referrer</td><td>string</td><td>Value of the "referer" header.  The comment is deliberately misspelled like the standard declares, but the name used here is "referrer", spelled correctly.</td></tr>

<tr><td>version</td><td>string</td><td>Value of the version portion of the reply. If you require message-level detail, consider the <b>http_request</b> and <b>http_reply</b> events, which report each message's version string.</td></tr>

<tr><td>user_agent</td><td>string</td><td>Value of the User-Agent header from the client.</td></tr>

<tr><td>origin</td><td>string</td><td>Value of the Origin header from the client.</td></tr>

<tr><td>request_body_len</td><td>integer - count</td><td>Actual uncompressed content size of the data transferred from the client.</td></tr>

<tr><td>response_body_len</td><td>integer - count</td><td>Actual uncompressed content size of the data transferred from the server.</td></tr>

<tr><td>status_code</td><td>integer - count</td><td>Status code returned by the server.</td></tr>

<tr><td>status_msg</td><td>string</td><td>Status message returned by the server.</td></tr>

<tr><td>info_code</td><td>integer - count</td><td>Last seen 1xx informational reply code returned by the server.</td></tr>

<tr><td>info_msg</td><td>string</td><td>Last seen 1xx informational reply message returned by the server.</td></tr>

<tr><td>tags</td><td>array[string] - set[enum]</td><td>A set of indicators of various attributes discovered and related to a particular request/response pair.</td></tr>

<tr><td>username</td><td>string</td><td>Username if basic-auth is performed for the request.</td></tr>

<tr><td>password</td><td>string</td><td>Password if basic-auth is performed for the request.</td></tr>

<tr><td>proxied</td><td>array[string] - set[string]</td><td>All of the headers that may indicate if the request was proxied.</td></tr>

<tr><td>orig_fuids</td><td>array[string] - vector of string</td><td>An ordered vector of file unique IDs. Limited to <b>HTTP::max_files_orig</b> entries.</td></tr>

<tr><td>orig_filenames</td><td>array[string] - vector of string</td><td>An ordered vector of filenames from the client. Limited to <b>HTTP::max_files_orig</b> entries.</td></tr>

<tr><td>orig_mime_types</td><td>array[string] - vector of string</td><td>An ordered vector of mime types. Limited to <b>HTTP::max_files_orig</b> entries.</td></tr>

<tr><td>resp_fuids</td><td>array[string] - vector of string</td><td>An ordered vector of file unique IDs. Limited to <b>HTTP::max_files_resp</b> entries.</td></tr>

<tr><td>resp_filenames</td><td>array[string] - vector of string</td><td>An ordered vector of filenames from the server. Limited to <b>HTTP::max_files_resp</b> entries.</td></tr>

<tr><td>resp_mime_types</td><td>array[string] - vector of string</td><td>An ordered vector of mime types. Limited to <b>HTTP::max_files_resp</b> entries.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">intel</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Timestamp when the data was discovered.</td></tr>

<tr><td>uid</td><td>string</td><td>If a connection was associated with this intelligence hit, this is the uid for the connection</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>seen.indicator</td><td>string</td><td>The string if the data is about a string.</td></tr>

<tr><td>seen.indicator_type</td><td>string - enum</td><td>The type of data that the indicator represents.</td></tr>

<tr><td>seen.where</td><td>string - enum</td><td>Where the data was discovered.</td></tr>

<tr><td>seen.node</td><td>string</td><td>The name of the node where the match was discovered.</td></tr>

<tr><td>matched</td><td>array[string] - set[enum]</td><td>Which indicator types matched.</td></tr>

<tr><td>sources</td><td>array[string] - set[string]</td><td>Sources which supplied data that resulted in this match.</td></tr>

<tr><td>fuid</td><td>string</td><td>If a file was associated with this intelligence hit, this is the uid for the file.</td></tr>

<tr><td>file_mime_type</td><td>string</td><td>A mime type if the intelligence hit is related to a file. If the $f field is provided this will be automatically filled out.</td></tr>

<tr><td>file_desc</td><td>string</td><td>Frequently files can be "described" to give a bit more context. If the $f field is provided this field will be automatically filled out.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">irc</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Timestamp when the command was seen.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique ID for the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>nick</td><td>string</td><td>Nickname given for the connection.</td></tr>

<tr><td>user</td><td>string</td><td>Username given for the connection.</td></tr>

<tr><td>command</td><td>string</td><td>Command given by the client.</td></tr>

<tr><td>value</td><td>string</td><td>Value for the command given by the client.</td></tr>

<tr><td>addl</td><td>string</td><td>Any additional data for the command.</td></tr>

<tr><td>dcc_file_name</td><td>string</td><td>DCC filename requested.</td></tr>

<tr><td>dcc_file_size</td><td>integer - count</td><td>Size of the DCC transfer as indicated by the sender.</td></tr>

<tr><td>dcc_mime_type</td><td>string</td><td>Sniffed mime type of the file.</td></tr>

<tr><td>fuid</td><td>string</td><td>File unique ID.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">kerberos</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Timestamp for when the event happened.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique ID for the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>request_type</td><td>string</td><td>Request type - Authentication Service ("AS") or Ticket Granting Service ("TGS")</td></tr>

<tr><td>client</td><td>string</td><td>Client</td></tr>

<tr><td>service</td><td>string</td><td>Service</td></tr>

<tr><td>success</td><td>boolean - bool</td><td>Request result</td></tr>

<tr><td>error_msg</td><td>string</td><td>Error message</td></tr>

<tr><td>from</td><td>time</td><td>Ticket valid from</td></tr>

<tr><td>till</td><td>time</td><td>Ticket valid till</td></tr>

<tr><td>cipher</td><td>string</td><td>Ticket encryption type</td></tr>

<tr><td>forwardable</td><td>boolean - bool</td><td>Forwardable ticket requested</td></tr>

<tr><td>renewable</td><td>boolean - bool</td><td>Renewable ticket requested</td></tr>

<tr><td>client_cert_subject</td><td>string</td><td>Subject of client certificate, if any</td></tr>

<tr><td>client_cert_fuid</td><td>string</td><td>File unique ID of client cert, if any</td></tr>

<tr><td>server_cert_subject</td><td>string</td><td>Subject of server certificate, if any</td></tr>

<tr><td>server_cert_fuid</td><td>string</td><td>File unique ID of server cert, if any</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">modbus</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Time of the request.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique identifier for the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>func</td><td>string</td><td>The name of the function message that was sent.</td></tr>

<tr><td>exception</td><td>string</td><td>The exception if the response was a failure.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">mysql</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Timestamp for when the event happened.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique ID for the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>cmd</td><td>string</td><td>The command that was issued</td></tr>

<tr><td>arg</td><td>string</td><td>The argument issued to the command</td></tr>

<tr><td>success</td><td>boolean - bool</td><td>Did the server tell us that the command succeeded?</td></tr>

<tr><td>rows</td><td>integer - count</td><td>The number of affected rows, if any</td></tr>

<tr><td>response</td><td>string</td><td>Server message, if any</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">notice</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>An absolute time indicating when the notice occurred, defaults to the current network time.</td></tr>

<tr><td>uid</td><td>string</td><td>A connection UID which uniquely identifies the endpoints concerned with the notice.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>fuid</td><td>string</td><td>A file unique ID if this notice is related to a file.  If the <b>f</b> field is provided, this will be automatically filled out.</td></tr>

<tr><td>file_mime_type</td><td>string</td><td>A mime type if the notice is related to a file.  If the <b>f</b> field is provided, this will be automatically filled out.</td></tr>

<tr><td>file_desc</td><td>string</td><td>Frequently files can be "described" to give a bit more context.  This field will typically be automatically filled out from an fa_file record.  For example, if a notice was related to a file over HTTP, the URL of the request would be shown.</td></tr>

<tr><td>proto</td><td>string - enum</td><td>The transport protocol. Filled automatically when either <b>conn</b>, <b>iconn</b> or <b>p</b> is specified.</td></tr>

<tr><td>note</td><td>string - enum</td><td>The <b>Notice::Type</b> of the notice.</td></tr>

<tr><td>msg</td><td>string</td><td>The human readable message for the notice.</td></tr>

<tr><td>sub</td><td>string</td><td>The human readable sub-message.</td></tr>

<tr><td>src</td><td>string - addr</td><td>Source address, if we don't have a <b>conn_id</b>.</td></tr>

<tr><td>dst</td><td>string - addr</td><td>Destination address.</td></tr>

<tr><td>p</td><td>integer - port</td><td>Associated port, if we don't have a <b>conn_id</b>.</td></tr>

<tr><td>n</td><td>integer - count</td><td>Associated count, or perhaps a status code.</td></tr>

<tr><td>peer_descr</td><td>string</td><td>Textual description for the peer that raised this notice, including name, host address and port.</td></tr>

<tr><td>actions</td><td>array[string] - set[enum]</td><td>The actions which have been applied to this notice.</td></tr>

<tr><td>email_dest</td><td>array[string] - set[string]</td><td>The email address(es) where to send this notice</td></tr>

<tr><td>suppress_for</td><td>number - interval</td><td>This field indicates the length of time that this unique notice should be suppressed.</td></tr>

<tr><td>remote_location.country_code</td><td>string</td><td>The country code.</td></tr>

<tr><td>remote_location.region</td><td>string</td><td>The region.</td></tr>

<tr><td>remote_location.city</td><td>string</td><td>The city.</td></tr>

<tr><td>remote_location.latitude</td><td>number - double</td><td>Latitude.</td></tr>

<tr><td>remote_location.longitude</td><td>number - double</td><td>Longitude.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">ntlm</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Timestamp for when the event happened.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique ID for the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>username</td><td>string</td><td>Username given by the client.</td></tr>

<tr><td>hostname</td><td>string</td><td>Hostname given by the client.</td></tr>

<tr><td>domainname</td><td>string</td><td>Domainname given by the client.</td></tr>

<tr><td>server_nb_computer_name</td><td>string</td><td>NetBIOS name given by the server in a CHALLENGE.</td></tr>

<tr><td>server_dns_computer_name</td><td>string</td><td>DNS name given by the server in a CHALLENGE.</td></tr>

<tr><td>server_tree_name</td><td>string</td><td>Tree name given by the server in a CHALLENGE.</td></tr>

<tr><td>success</td><td>boolean - bool</td><td>Indicate whether or not the authentication was successful.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">ntp</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Timestamp for when the event happened.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique ID for the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>version</td><td>integer - count</td><td>The NTP version number (1, 2, 3, 4).</td></tr>

<tr><td>mode</td><td>integer - count</td><td>The NTP mode being used.</td></tr>

<tr><td>stratum</td><td>integer - count</td><td>The stratum (primary server, secondary server, etc.).</td></tr>

<tr><td>poll</td><td>number - interval</td><td>The maximum interval between successive messages.</td></tr>

<tr><td>precision</td><td>number - interval</td><td>The precision of the system clock.</td></tr>

<tr><td>root_delay</td><td>number - interval</td><td>Total round-trip delay to the reference clock.</td></tr>

<tr><td>root_disp</td><td>number - interval</td><td>Total dispersion to the reference clock.</td></tr>

<tr><td>ref_id</td><td>string</td><td>For stratum 0, 4 character string used for debugging. For stratum 1, ID assigned to the reference clock by IANA. Above stratum 1, when using IPv4, the IP address of the reference clock.  Note that the NTP protocol did not originally specify a large enough field to represent IPv6 addresses, so they use the first four bytes of the MD5 hash of the reference clock's IPv6 address (i.e. an IPv4 address here is not necessarily IPv4).</td></tr>

<tr><td>ref_time</td><td>time</td><td>Time when the system clock was last set or correct.</td></tr>

<tr><td>org_time</td><td>time</td><td>Time at the client when the request departed for the NTP server.</td></tr>

<tr><td>rec_time</td><td>time</td><td>Time at the server when the request arrived from the NTP client.</td></tr>

<tr><td>xmt_time</td><td>time</td><td>Time at the server when the response departed for the NTP client.</td></tr>

<tr><td>num_exts</td><td>integer - count</td><td>Number of extension fields (which are not currently parsed).</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">pe</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Current timestamp.</td></tr>

<tr><td>id</td><td>string</td><td>File id of this portable executable file.</td></tr>

<tr><td>machine</td><td>string</td><td>The target machine that the file was compiled for.</td></tr>

<tr><td>compile_ts</td><td>time</td><td>The time that the file was created at.</td></tr>

<tr><td>os</td><td>string</td><td>The required operating system.</td></tr>

<tr><td>subsystem</td><td>string</td><td>The subsystem that is required to run this file.</td></tr>

<tr><td>is_exe</td><td>boolean - bool</td><td>Is the file an executable, or just an object file?</td></tr>

<tr><td>is_64bit</td><td>boolean - bool</td><td>Is the file a 64-bit executable?</td></tr>

<tr><td>uses_aslr</td><td>boolean - bool</td><td>Does the file support Address Space Layout Randomization?</td></tr>

<tr><td>uses_dep</td><td>boolean - bool</td><td>Does the file support Data Execution Prevention?</td></tr>

<tr><td>uses_code_integrity</td><td>boolean - bool</td><td>Does the file enforce code integrity checks?</td></tr>

<tr><td>uses_seh</td><td>boolean - bool</td><td>Does the file use structured exception handing?</td></tr>

<tr><td>has_import_table</td><td>boolean - bool</td><td>Does the file have an import table?</td></tr>

<tr><td>has_export_table</td><td>boolean - bool</td><td>Does the file have an export table?</td></tr>

<tr><td>has_cert_table</td><td>boolean - bool</td><td>Does the file have an attribute certificate table?</td></tr>

<tr><td>has_debug_data</td><td>boolean - bool</td><td>Does the file have a debug table?</td></tr>

<tr><td>section_names</td><td>array[string] - vector of string</td><td>The names of the sections, in order.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">radius</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Timestamp for when the event happened.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique ID for the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>username</td><td>string</td><td>The username, if present.</td></tr>

<tr><td>mac</td><td>string</td><td>MAC address, if present.</td></tr>

<tr><td>framed_addr</td><td>string - addr</td><td>The address given to the network access server, if present.  This is only a hint from the RADIUS server and the network access server is not required to honor the address.</td></tr>

<tr><td>tunnel_client</td><td>string</td><td>Address (IPv4, IPv6, or FQDN) of the initiator end of the tunnel, if present.  This is collected from the Tunnel-Client-Endpoint attribute.</td></tr>

<tr><td>connect_info</td><td>string</td><td>Connect info, if present.</td></tr>

<tr><td>reply_msg</td><td>string</td><td>Reply message from the server challenge. This is frequently shown to the user authenticating.</td></tr>

<tr><td>result</td><td>string</td><td>Successful or failed authentication.</td></tr>

<tr><td>ttl</td><td>number - interval</td><td>The duration between the first request and either the "Access-Accept" message or an error. If the field is empty, it means that either the request or response was not seen.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">rdp</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Timestamp for when the event happened.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique ID for the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>cookie</td><td>string</td><td>Cookie value used by the client machine. This is typically a username.</td></tr>

<tr><td>result</td><td>string</td><td>Status result for the connection.  It's a mix between RDP negotation failure messages and GCC server create response messages.</td></tr>

<tr><td>security_protocol</td><td>string</td><td>Security protocol chosen by the server.</td></tr>

<tr><td>client_channels</td><td>array[string] - vector of string</td><td>The channels requested by the client</td></tr>

<tr><td>keyboard_layout</td><td>string</td><td>Keyboard layout (language) of the client machine.</td></tr>

<tr><td>client_build</td><td>string</td><td>RDP client version used by the client machine.</td></tr>

<tr><td>client_name</td><td>string</td><td>Name of the client machine.</td></tr>

<tr><td>client_dig_product_id</td><td>string</td><td>Product ID of the client machine.</td></tr>

<tr><td>desktop_width</td><td>integer - count</td><td>Desktop width of the client machine.</td></tr>

<tr><td>desktop_height</td><td>integer - count</td><td>Desktop height of the client machine.</td></tr>

<tr><td>requested_color_depth</td><td>string</td><td>The color depth requested by the client in the high_color_depth field.</td></tr>

<tr><td>cert_type</td><td>string</td><td>If the connection is being encrypted with native RDP encryption, this is the type of cert being used.</td></tr>

<tr><td>cert_count</td><td>integer - count</td><td>The number of certs seen.  X.509 can transfer an entire certificate chain.</td></tr>

<tr><td>cert_permanent</td><td>boolean - bool</td><td>Indicates if the provided certificate or certificate chain is permanent or temporary.</td></tr>

<tr><td>encryption_level</td><td>string</td><td>Encryption level of the connection.</td></tr>

<tr><td>encryption_method</td><td>string</td><td>Encryption method of the connection.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">reporter</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>The network time at which the reporter event was generated.</td></tr>

<tr><td>level</td><td>string - enum</td><td>The severity of the reporter message. Levels are INFO for informational messages, not needing specific attention; WARNING for warning of a potential problem, and ERROR for a non-fatal error that should be addressed, but doesn't terminate program execution.</td></tr>

<tr><td>message</td><td>string</td><td>An info/warning/error message that could have either been generated from the internal Zeek core or at the scripting-layer.</td></tr>

<tr><td>location</td><td>string</td><td>This is the location in a Zeek script where the message originated. Not all reporter messages will have locations in them though.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">rfb</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Timestamp for when the event happened.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique ID for the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>client_major_version</td><td>string</td><td>Major version of the client.</td></tr>

<tr><td>client_minor_version</td><td>string</td><td>Minor version of the client.</td></tr>

<tr><td>server_major_version</td><td>string</td><td>Major version of the server.</td></tr>

<tr><td>server_minor_version</td><td>string</td><td>Minor version of the server.</td></tr>

<tr><td>authentication_method</td><td>string</td><td>Identifier of authentication method used.</td></tr>

<tr><td>auth</td><td>boolean - bool</td><td>Whether or not authentication was successful.</td></tr>

<tr><td>share_flag</td><td>boolean - bool</td><td>Whether the client has an exclusive or a shared session.</td></tr>

<tr><td>desktop_name</td><td>string</td><td>Name of the screen that is being shared.</td></tr>

<tr><td>width</td><td>integer - count</td><td>Width of the screen that is being shared.</td></tr>

<tr><td>height</td><td>integer - count</td><td>Height of the screen that is being shared.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">sip</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Timestamp for when the request happened.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique ID for the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>trans_depth</td><td>integer - count</td><td>Represents the pipelined depth into the connection of this request/response transaction.</td></tr>

<tr><td>method</td><td>string</td><td>Verb used in the SIP request (INVITE, REGISTER etc.).</td></tr>

<tr><td>uri</td><td>string</td><td>URI used in the request.</td></tr>

<tr><td>date</td><td>string</td><td>Contents of the Date: header from the client</td></tr>

<tr><td>request_from</td><td>string</td><td>Contents of the request From: header Note: The tag= value that's usually appended to the sender is stripped off and not logged.</td></tr>

<tr><td>request_to</td><td>string</td><td>Contents of the To: header</td></tr>

<tr><td>response_from</td><td>string</td><td>Contents of the response From: header Note: The `tag=` value that's usually appended to the sender is stripped off and not logged.</td></tr>

<tr><td>response_to</td><td>string</td><td>Contents of the response To: header</td></tr>

<tr><td>reply_to</td><td>string</td><td>Contents of the Reply-To: header</td></tr>

<tr><td>call_id</td><td>string</td><td>Contents of the Call-ID: header from the client</td></tr>

<tr><td>seq</td><td>string</td><td>Contents of the CSeq: header from the client</td></tr>

<tr><td>subject</td><td>string</td><td>Contents of the Subject: header from the client</td></tr>

<tr><td>request_path</td><td>array[string] - vector of string</td><td>The client message transmission path, as extracted from the headers.</td></tr>

<tr><td>response_path</td><td>array[string] - vector of string</td><td>The server message transmission path, as extracted from the headers.</td></tr>

<tr><td>user_agent</td><td>string</td><td>Contents of the User-Agent: header from the client</td></tr>

<tr><td>status_code</td><td>integer - count</td><td>Status code returned by the server.</td></tr>

<tr><td>status_msg</td><td>string</td><td>Status message returned by the server.</td></tr>

<tr><td>warning</td><td>string</td><td>Contents of the Warning: header</td></tr>

<tr><td>request_body_len</td><td>integer - count</td><td>Contents of the Content-Length: header from the client</td></tr>

<tr><td>response_body_len</td><td>integer - count</td><td>Contents of the Content-Length: header from the server</td></tr>

<tr><td>content_type</td><td>string</td><td>Contents of the Content-Type: header from the server</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">smb_files</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Time when the file was first discovered.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique ID of the connection the file was sent over.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>fuid</td><td>string</td><td>Unique ID of the file.</td></tr>

<tr><td>action</td><td>string - enum</td><td>Action this log record represents.</td></tr>

<tr><td>path</td><td>string</td><td>Path pulled from the tree this file was transferred to or from.</td></tr>

<tr><td>name</td><td>string</td><td>Filename if one was seen.</td></tr>

<tr><td>size</td><td>integer - count</td><td>Total size of the file.</td></tr>

<tr><td>prev_name</td><td>string</td><td>If the rename action was seen, this will be the file's previous name.</td></tr>

<tr><td>times.modified</td><td>time</td><td>The time when data was last written to the file.</td></tr>

<tr><td>times.accessed</td><td>time</td><td>The time when the file was last accessed.</td></tr>

<tr><td>times.created</td><td>time</td><td>The time the file was created.</td></tr>

<tr><td>times.changed</td><td>time</td><td>The time when the file was last modified.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">smb_mapping</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Time when the tree was mapped.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique ID of the connection the tree was mapped over.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>path</td><td>string</td><td>Name of the tree path.</td></tr>

<tr><td>service</td><td>string</td><td>The type of resource of the tree (disk share, printer share, named pipe, etc.).</td></tr>

<tr><td>native_file_system</td><td>string</td><td>File system of the tree.</td></tr>

<tr><td>share_type</td><td>string</td><td>If this is SMB2, a share type will be included.  For SMB1, the type of share will be deduced and included as well.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">smtp</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Time when the message was first seen.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique ID for the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>trans_depth</td><td>integer - count</td><td>A count to represent the depth of this message transaction in a single connection where multiple messages were transferred.</td></tr>

<tr><td>helo</td><td>string</td><td>Contents of the Helo header.</td></tr>

<tr><td>mailfrom</td><td>string</td><td>Email addresses found in the From header.</td></tr>

<tr><td>rcptto</td><td>array[string] - set[string]</td><td>Email addresses found in the Rcpt header.</td></tr>

<tr><td>date</td><td>string</td><td>Contents of the Date header.</td></tr>

<tr><td>from</td><td>string</td><td>Contents of the From header.</td></tr>

<tr><td>to</td><td>array[string] - set[string]</td><td>Contents of the To header.</td></tr>

<tr><td>cc</td><td>array[string] - set[string]</td><td>Contents of the CC header.</td></tr>

<tr><td>reply_to</td><td>string</td><td>Contents of the ReplyTo header.</td></tr>

<tr><td>msg_id</td><td>string</td><td>Contents of the MsgID header.</td></tr>

<tr><td>in_reply_to</td><td>string</td><td>Contents of the In-Reply-To header.</td></tr>

<tr><td>subject</td><td>string</td><td>Contents of the Subject header.</td></tr>

<tr><td>x_originating_ip</td><td>string - addr</td><td>Contents of the X-Originating-IP header.</td></tr>

<tr><td>first_received</td><td>string</td><td>Contents of the first Received header.</td></tr>

<tr><td>second_received</td><td>string</td><td>Contents of the second Received header.</td></tr>

<tr><td>last_reply</td><td>string</td><td>The last message that the server sent to the client.</td></tr>

<tr><td>path</td><td>array[string] - vector of addr</td><td>The message transmission path, as extracted from the headers.</td></tr>

<tr><td>user_agent</td><td>string</td><td>Value of the User-Agent header from the client.</td></tr>

<tr><td>tls</td><td>boolean - bool</td><td>Indicates that the connection has switched to using TLS.</td></tr>

<tr><td>fuids</td><td>array[string] - vector of string</td><td>An ordered vector of file unique IDs seen attached to the message.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">snmp</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Timestamp of first packet belonging to the SNMP session.</td></tr>

<tr><td>uid</td><td>string</td><td>The unique ID for the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>duration</td><td>number - interval</td><td>The amount of time between the first packet beloning to the SNMP session and the latest one seen.</td></tr>

<tr><td>version</td><td>string</td><td>The version of SNMP being used.</td></tr>

<tr><td>community</td><td>string</td><td>The community string of the first SNMP packet associated with the session.  This is used as part of SNMP's (v1 and v2c) administrative/security framework.  See :rfc:<b>1157</b> or :rfc:<b>1901</b>.</td></tr>

<tr><td>get_requests</td><td>integer - count</td><td>The number of variable bindings in GetRequest/GetNextRequest PDUs seen for the session.</td></tr>

<tr><td>get_bulk_requests</td><td>integer - count</td><td>The number of variable bindings in GetBulkRequest PDUs seen for the session.</td></tr>

<tr><td>get_responses</td><td>integer - count</td><td>The number of variable bindings in GetResponse/Response PDUs seen for the session.</td></tr>

<tr><td>set_requests</td><td>integer - count</td><td>The number of variable bindings in SetRequest PDUs seen for the session.</td></tr>

<tr><td>display_string</td><td>string</td><td>A system description of the SNMP responder endpoint.</td></tr>

<tr><td>up_since</td><td>time</td><td>The time at which the SNMP responder endpoint claims it's been up since.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">socks</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Time when the proxy connection was first detected.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique ID for the tunnel - may correspond to connection uid or be non-existent.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>version</td><td>integer - count</td><td>Protocol version of SOCKS.</td></tr>

<tr><td>user</td><td>string</td><td>Username used to request a login to the proxy.</td></tr>

<tr><td>password</td><td>string</td><td>Password used to request a login to the proxy.</td></tr>

<tr><td>status</td><td>string</td><td>Server status for the attempt at using the proxy.</td></tr>

<tr><td>request.host</td><td>string - addr</td><td>The request.host information.</td></tr>

<tr><td>request.name</td><td>string</td><td>The request.name information.</td></tr>

<tr><td>request_p</td><td>integer - port</td><td>Client requested port.</td></tr>

<tr><td>bound.host</td><td>string - addr</td><td>The bound.host information.</td></tr>

<tr><td>bound.name</td><td>string</td><td>The bound.name information.</td></tr>

<tr><td>bound_p</td><td>integer - port</td><td>Server bound port.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">software</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>The time at which the software was detected.</td></tr>

<tr><td>host</td><td>string - addr</td><td>The IP address detected running the software.</td></tr>

<tr><td>host_p</td><td>integer - port</td><td>The port on which the software is running. Only sensible for server software.</td></tr>

<tr><td>software_type</td><td>string - enum</td><td>The type of software detected (e.g. <b>HTTP::SERVER</b>).</td></tr>

<tr><td>name</td><td>string</td><td>Name of the software (e.g. Apache).</td></tr>

<tr><td>version.major</td><td>integer - count</td><td>Major version number.</td></tr>

<tr><td>version.minor</td><td>integer - count</td><td>Minor version number.</td></tr>

<tr><td>version.minor2</td><td>integer - count</td><td>Minor subversion number.</td></tr>

<tr><td>version.minor3</td><td>integer - count</td><td>Minor updates number.</td></tr>

<tr><td>version.addl</td><td>string</td><td>Additional version string (e.g. "beta42").</td></tr>

<tr><td>unparsed_version</td><td>string</td><td>The full unparsed version string found because the version parsing doesn't always work reliably in all cases and this acts as a fallback in the logs.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">ssh</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Time when the SSH connection began.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique ID for the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>version</td><td>integer - count</td><td>SSH major version (1, 2, or unset). The version can be unset if the client and server version strings are unset, malformed or incompatible so no common version can be extracted. If no version can be extracted even though both client and server versions are set a weird will be generated.</td></tr>

<tr><td>auth_success</td><td>boolean - bool</td><td>Authentication result (T=success, F=failure, unset=unknown)</td></tr>

<tr><td>auth_attempts</td><td>integer - count</td><td>The number of authentication attemps we observed. There's always at least one, since some servers might support no authentication at all. It's important to note that not all of these are failures, since some servers require two-factor auth (e.g. password AND pubkey)</td></tr>

<tr><td>direction</td><td>string - enum</td><td>Direction of the connection. If the client was a local host logging into an external host, this would be OUTBOUND. INBOUND would be set for the opposite situation.</td></tr>

<tr><td>client</td><td>string</td><td>The client's version string</td></tr>

<tr><td>server</td><td>string</td><td>The server's version string</td></tr>

<tr><td>cipher_alg</td><td>string</td><td>The encryption algorithm in use</td></tr>

<tr><td>mac_alg</td><td>string</td><td>The signing (MAC) algorithm in use</td></tr>

<tr><td>compression_alg</td><td>string</td><td>The compression algorithm in use</td></tr>

<tr><td>kex_alg</td><td>string</td><td>The key exchange algorithm in use</td></tr>

<tr><td>host_key_alg</td><td>string</td><td>The server host key's algorithm</td></tr>

<tr><td>host_key</td><td>string</td><td>The server's key fingerprint</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">ssl</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Time when the SSL connection was first detected.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique ID for the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>version</td><td>string</td><td>SSL/TLS version that the server chose.</td></tr>

<tr><td>cipher</td><td>string</td><td>SSL/TLS cipher suite that the server chose.</td></tr>

<tr><td>curve</td><td>string</td><td>Elliptic curve the server chose when using ECDH/ECDHE.</td></tr>

<tr><td>server_name</td><td>string</td><td>Value of the Server Name Indicator SSL/TLS extension.  It indicates the server name that the client was requesting.</td></tr>

<tr><td>resumed</td><td>boolean - bool</td><td>Flag to indicate if the session was resumed reusing the key material exchanged in an earlier connection.</td></tr>

<tr><td>last_alert</td><td>string</td><td>Last alert that was seen during the connection.</td></tr>

<tr><td>next_protocol</td><td>string</td><td>Next protocol the server chose using the application layer next protocol extension, if present.</td></tr>

<tr><td>established</td><td>boolean - bool</td><td>Flag to indicate if this ssl session has been established successfully, or if it was aborted during the handshake.</td></tr>

<tr><td>ssl_history</td><td>string</td><td><table summary="deets"><tbody> <tr><td>H</td><td>hello_request</td></tr>  <tr><td>C</td><td>client_hello</td></tr>  <tr><td>S</td><td>server_hello</td></tr>  <tr><td>V</td><td>hello_verify_request</td></tr>  <tr><td>T</td><td>NewSessionTicket</td></tr>  <tr><td>X</td><td>certificate</td></tr>  <tr><td>K</td><td>server_key_exchange</td></tr>  <tr><td>R</td><td>certificate_request</td></tr>  <tr><td>N</td><td>server_hello_done</td></tr>  <tr><td>Y</td><td>certificate_verify</td></tr>  <tr><td>G</td><td>client_key_exchange</td></tr>  <tr><td>F</td><td>finished</td></tr>  <tr><td>W</td><td>certificate_url</td></tr>  <tr><td>U</td><td>certificate_status</td></tr>  <tr><td>A</td><td>supplemental_data</td></tr>  <tr><td>Z</td><td>unassigned_handshake_type</td></tr>  <tr><td>I</td><td>change_cipher_spec</td></tr>  <tr><td>B</td><td>heartbeat</td></tr>  <tr><td>D</td><td>application_data</td></tr>  <tr><td>E</td><td>end_of_early_data</td></tr>  <tr><td>O</td><td>encrypted_extensions</td></tr>  <tr><td>P</td><td>key_update</td></tr>  <tr><td>M</td><td>message_hash</td></tr>  <tr><td>J</td><td>hello_retry_request</td></tr>  <tr><td>L</td><td>alert</td></tr>  <tr><td>Q</td><td>unknown_content_type</td></tr>  </tbody></table></td></tr>

<tr><td>cert_chain_fps</td><td>array[string] - vector of string</td><td>An ordered vector of all certificate fingerprints for the certificates offered by the server.</td></tr>

<tr><td>client_cert_chain_fps</td><td>array[string] - vector of string</td><td>An ordered vector of all certificate fingerprints for the certificates offered by the client.</td></tr>

<tr><td>sni_matches_cert</td><td>boolean - bool</td><td>Set to true if the hostname sent in the SNI matches the certificate. Set to false if they do not match. Unset if the client did not send an SNI.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">syslog</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Timestamp when the syslog message was seen.</td></tr>

<tr><td>uid</td><td>string</td><td>Unique ID for the connection.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>proto</td><td>string - enum</td><td>Protocol over which the message was seen.</td></tr>

<tr><td>facility</td><td>string</td><td>Syslog facility for the message.</td></tr>

<tr><td>severity</td><td>string</td><td>Syslog severity for the message.</td></tr>

<tr><td>message</td><td>string</td><td>The plain text message.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">tunnel</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Time at which some tunnel activity occurred.</td></tr>

<tr><td>uid</td><td>string</td><td>The unique identifier for the tunnel, which may correspond to a <b>connection</b>'s <b>uid</b> field for non-IP-in-IP tunnels. This is optional because there could be numerous connections for payload proxies like SOCKS but we should treat it as a single tunnel.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>tunnel_type</td><td>string - enum</td><td>The type of tunnel.</td></tr>

<tr><td>action</td><td>string - enum</td><td>The type of activity that occurred.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">weird</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>The time when the weird occurred.</td></tr>

<tr><td>uid</td><td>string</td><td>If a connection is associated with this weird, this will be the connection's unique ID.</td></tr>

<tr><td>id.orig_h</td><td>string - addr</td><td>The originator's IP address.</td></tr>

<tr><td>id.orig_p</td><td>integer - port</td><td>The originator's port number.</td></tr>

<tr><td>id.resp_h</td><td>string - addr</td><td>The responder's IP address.</td></tr>

<tr><td>id.resp_p</td><td>integer - port</td><td>The responder's port number.</td></tr>

<tr><td>name</td><td>string</td><td>The name of the weird that occurred.</td></tr>

<tr><td>addl</td><td>string</td><td>Additional information accompanying the weird if any.</td></tr>

<tr><td>notice</td><td>boolean - bool</td><td>Indicate if this weird was also turned into a notice.</td></tr>

<tr><td>peer</td><td>string</td><td>The peer that originated this weird.  This is helpful in cluster deployments if a particular cluster node is having trouble to help identify which node is having trouble.</td></tr>

<tr><td>source</td><td>string</td><td>The source of the weird. When reported by an analyzer, this should be the name of the analyzer.</td></tr>

</tbody>      </table>    </div>
    <button type="button" class="collapsible">x509</button>
    <div class="content">     
 <p>Log Description goes here when zeek version allows.</p>
<table class="GeneratedTable" summary="log info">
 <thead>   <tr> <th>Field name</th>     <th>Type<br>JSON - Zeek</th>     <th>Definition</th>   </tr> </thead>
<tbody>
<tr><td>ts</td><td>time</td><td>Current timestamp.</td></tr>

<tr><td>fingerprint</td><td>string</td><td>Fingerprint of the certificate - uses chosen algorithm.</td></tr>

<tr><td>certificate.version</td><td>integer - count</td><td>Version number.</td></tr>

<tr><td>certificate.serial</td><td>string</td><td>Serial number.</td></tr>

<tr><td>certificate.subject</td><td>string</td><td>Subject.</td></tr>

<tr><td>certificate.issuer</td><td>string</td><td>Issuer.</td></tr>

<tr><td>certificate.not_valid_before</td><td>time</td><td>Timestamp before when certificate is not valid.</td></tr>

<tr><td>certificate.not_valid_after</td><td>time</td><td>Timestamp after when certificate is not valid.</td></tr>

<tr><td>certificate.key_alg</td><td>string</td><td>Name of the key algorithm</td></tr>

<tr><td>certificate.sig_alg</td><td>string</td><td>Name of the signature algorithm</td></tr>

<tr><td>certificate.key_type</td><td>string</td><td>Key type, if key parseable by openssl (either rsa, dsa or ec)</td></tr>

<tr><td>certificate.key_length</td><td>integer - count</td><td>Key length in bits</td></tr>

<tr><td>certificate.exponent</td><td>string</td><td>Exponent, if RSA-certificate</td></tr>

<tr><td>certificate.curve</td><td>string</td><td>Curve, if EC-certificate</td></tr>

<tr><td>san.dns</td><td>array[string] - vector of string</td><td>List of DNS entries in SAN</td></tr>

<tr><td>san.uri</td><td>array[string] - vector of string</td><td>List of URI entries in SAN</td></tr>

<tr><td>san.email</td><td>array[string] - vector of string</td><td>List of email entries in SAN</td></tr>

<tr><td>san.ip</td><td>array[string] - vector of addr</td><td>List of IP entries in SAN</td></tr>

<tr><td>basic_constraints.ca</td><td>boolean - bool</td><td>CA flag set?</td></tr>

<tr><td>basic_constraints.path_len</td><td>integer - count</td><td>Maximum path length</td></tr>

<tr><td>host_cert</td><td>boolean - bool</td><td>Indicates if this certificate was a end-host certificate, or sent as part of a chain</td></tr>

<tr><td>client_cert</td><td>boolean - bool</td><td>Indicates if this certificate was sent from the client</td></tr>

</tbody>      </table>    </div>
    <script type="application/javascript">
      var coll = document.getElementsByClassName("collapsible");
      var i;

      for (i = 0; i < coll.length; i++) {
   coll[i].addEventListener("click", function() {
       this.classList.toggle("active");
       var content = this.nextElementSibling;
       if (content.style.display === "block") {
    content.style.display = "none";
       } else {
    content.style.display = "block";
       }
   });
      }       
    </script>
  </body>
</html>

